"""Pull Request management service."""

import subprocess
import tempfile
import uuid
from pathlib import Path
from urllib.parse import urlparse

import git
import httpx

from dursor_api.config import settings
from dursor_api.domain.models import PR, PRCreate, PRUpdate, Run
from dursor_api.services.repo_service import RepoService
from dursor_api.storage.dao import PRDAO, RunDAO, TaskDAO


class PRService:
    """Service for managing Pull Requests."""

    def __init__(
        self,
        pr_dao: PRDAO,
        task_dao: TaskDAO,
        run_dao: RunDAO,
        repo_service: RepoService,
    ):
        self.pr_dao = pr_dao
        self.task_dao = task_dao
        self.run_dao = run_dao
        self.repo_service = repo_service
        self.github_pat = settings.github_pat

    def _parse_github_url(self, repo_url: str) -> tuple[str, str]:
        """Parse owner and repo from GitHub URL.

        Args:
            repo_url: GitHub repository URL.

        Returns:
            Tuple of (owner, repo_name).
        """
        # Handle different URL formats
        if repo_url.startswith("git@github.com:"):
            path = repo_url.replace("git@github.com:", "").replace(".git", "")
        else:
            parsed = urlparse(repo_url)
            path = parsed.path.strip("/").replace(".git", "")

        parts = path.split("/")
        if len(parts) != 2:
            raise ValueError(f"Invalid GitHub URL: {repo_url}")

        return parts[0], parts[1]

    async def create(self, task_id: str, data: PRCreate) -> PR:
        """Create a new Pull Request.

        Args:
            task_id: Task ID.
            data: PR creation data.

        Returns:
            Created PR object.
        """
        if not self.github_pat:
            raise ValueError("GitHub PAT not configured")

        # Get task and repo
        task = await self.task_dao.get(task_id)
        if not task:
            raise ValueError(f"Task not found: {task_id}")

        repo_obj = await self.repo_service.get(task.repo_id)
        if not repo_obj:
            raise ValueError(f"Repo not found: {task.repo_id}")

        # Get run
        run = await self.run_dao.get(data.selected_run_id)
        if not run:
            raise ValueError(f"Run not found: {data.selected_run_id}")
        if not run.patch:
            raise ValueError("Run has no patch to apply")

        # Parse GitHub info
        owner, repo_name = self._parse_github_url(repo_obj.repo_url)

        # Create branch name
        branch_name = f"dursor/{uuid.uuid4().hex[:8]}"

        # Apply patch and create branch
        workspace_path = Path(repo_obj.workspace_path)
        repo = git.Repo(workspace_path)

        # Create and checkout new branch
        new_branch = repo.create_head(branch_name)
        new_branch.checkout()

        # Apply patch
        patch_file = workspace_path / ".dursor_patch.diff"
        try:
            patch_file.write_text(run.patch)
            subprocess.run(
                ["git", "apply", str(patch_file)],
                cwd=workspace_path,
                check=True,
                capture_output=True,
            )
        finally:
            patch_file.unlink(missing_ok=True)

        # Commit changes
        repo.git.add(".")
        repo.index.commit(data.title)

        # Push branch
        # Configure remote with PAT
        auth_url = f"https://x-access-token:{self.github_pat}@github.com/{owner}/{repo_name}.git"
        repo.git.push(auth_url, branch_name)

        # Create PR via GitHub API
        async with httpx.AsyncClient() as client:
            response = await client.post(
                f"https://api.github.com/repos/{owner}/{repo_name}/pulls",
                headers={
                    "Authorization": f"Bearer {self.github_pat}",
                    "Accept": "application/vnd.github+json",
                    "X-GitHub-Api-Version": "2022-11-28",
                },
                json={
                    "title": data.title,
                    "body": data.body or f"Generated by dursor\n\n{run.summary}",
                    "head": branch_name,
                    "base": repo_obj.default_branch,
                },
            )
            response.raise_for_status()
            pr_data = response.json()

        # Switch back to default branch
        repo.heads[repo_obj.default_branch].checkout()

        # Save to database
        return await self.pr_dao.create(
            task_id=task_id,
            number=pr_data["number"],
            url=pr_data["html_url"],
            branch=branch_name,
            title=data.title,
            body=data.body,
            latest_commit=repo.head.commit.hexsha,
        )

    async def update(self, task_id: str, pr_id: str, data: PRUpdate) -> PR:
        """Update an existing Pull Request.

        Args:
            task_id: Task ID.
            pr_id: PR ID.
            data: PR update data.

        Returns:
            Updated PR object.
        """
        if not self.github_pat:
            raise ValueError("GitHub PAT not configured")

        # Get PR
        pr = await self.pr_dao.get(pr_id)
        if not pr or pr.task_id != task_id:
            raise ValueError(f"PR not found: {pr_id}")

        # Get task and repo
        task = await self.task_dao.get(task_id)
        if not task:
            raise ValueError(f"Task not found: {task_id}")

        repo_obj = await self.repo_service.get(task.repo_id)
        if not repo_obj:
            raise ValueError(f"Repo not found: {task.repo_id}")

        # Get run
        run = await self.run_dao.get(data.selected_run_id)
        if not run:
            raise ValueError(f"Run not found: {data.selected_run_id}")
        if not run.patch:
            raise ValueError("Run has no patch to apply")

        # Parse GitHub info
        owner, repo_name = self._parse_github_url(repo_obj.repo_url)

        # Apply patch to existing branch
        workspace_path = Path(repo_obj.workspace_path)
        repo = git.Repo(workspace_path)

        # Checkout PR branch
        repo.git.checkout(pr.branch)

        # Apply patch
        patch_file = workspace_path / ".dursor_patch.diff"
        try:
            patch_file.write_text(run.patch)
            subprocess.run(
                ["git", "apply", str(patch_file)],
                cwd=workspace_path,
                check=True,
                capture_output=True,
            )
        finally:
            patch_file.unlink(missing_ok=True)

        # Commit changes
        repo.git.add(".")
        commit_message = data.message or f"Update: {run.summary}"
        repo.index.commit(commit_message)

        # Push
        auth_url = f"https://x-access-token:{self.github_pat}@github.com/{owner}/{repo_name}.git"
        repo.git.push(auth_url, pr.branch)

        latest_commit = repo.head.commit.hexsha

        # Switch back to default branch
        repo.heads[repo_obj.default_branch].checkout()

        # Update database
        await self.pr_dao.update(pr_id, latest_commit)

        return await self.pr_dao.get(pr_id)

    async def get(self, task_id: str, pr_id: str) -> PR | None:
        """Get a PR by ID.

        Args:
            task_id: Task ID.
            pr_id: PR ID.

        Returns:
            PR object or None if not found.
        """
        pr = await self.pr_dao.get(pr_id)
        if pr and pr.task_id == task_id:
            return pr
        return None

    async def list(self, task_id: str) -> list[PR]:
        """List PRs for a task.

        Args:
            task_id: Task ID.

        Returns:
            List of PR objects.
        """
        return await self.pr_dao.list(task_id)
